# ğŸš€ è½»é‡é«˜æ•ˆçš„å‡½æ•°å¼åˆ‡ç‰‡æ¶æ„ v7.0

## 1. æ ¸å¿ƒè®¾è®¡ç†å¿µ

v7è®¾è®¡ç»§æ‰¿v6çš„æ‰€æœ‰ä¼˜ç§€ç‰¹æ€§ï¼Œä½¿ç”¨**é™æ€åˆ†å‘+æ³›å‹**ä»£æ›¿å¤æ‚çš„å®ç³»ç»Ÿï¼Œå®ç°æ›´ç®€æ´ã€æ›´å¯é çš„æ¶æ„ï¼š

- **å‡½æ•°ä¼˜å…ˆ**ï¼šä»¥å‡½æ•°ä¸ºåŸºæœ¬å•å…ƒï¼Œä¼˜å…ˆäºç»“æ„ä½“å’Œç±»
- **é™æ€åˆ†å‘**ï¼šä½¿ç”¨æ³›å‹å‚æ•°å®ç°é›¶å¼€é”€æŠ½è±¡ï¼Œç¼–è¯‘æ—¶å•æ€åŒ–
- **åŒè·¯å¾„æš´éœ²**ï¼šå‡½æ•°åŒæ—¶æ”¯æŒå†…éƒ¨è°ƒç”¨å’Œå¤–éƒ¨HTTPè®¿é—®
- **æ¥å£é©±åŠ¨è®¾è®¡**ï¼šé€šè¿‡æ¥å£å®ç°æ¾è€¦åˆï¼Œæ”¯æŒçµæ´»ç»„åˆ
- **ç±»å‹å®‰å…¨æ³¨å…¥**ï¼šç¼–è¯‘æ—¶ç±»å‹å®‰å…¨çš„ä¾èµ–æ³¨å…¥
- **é›¶å¼€é”€è°ƒç”¨è·¯å¾„**ï¼šé™æ€åˆ†å‘æ¶ˆé™¤è¿è¡Œæ—¶å¼€é”€
- **æ˜¾å¼ä¾èµ–**ï¼šé€šè¿‡æ³›å‹å‚æ•°æ˜ç¡®ä¾èµ–å…³ç³»
- **ç»Ÿä¸€é”™è¯¯å¤„ç†**ï¼šå®Œæ•´çš„é”™è¯¯å¤„ç†ç³»ç»Ÿï¼Œæ”¯æŒä¸Šä¸‹æ–‡å’Œè¿½è¸ª

## 2. æ¶æ„åˆ†å±‚ä¸ç»„ä»¶

```
app/
â”œâ”€â”€ slices/             # åŠŸèƒ½åˆ‡ç‰‡
â”‚   â”œâ”€â”€ auth/           # è®¤è¯åˆ‡ç‰‡
â”‚   â”œâ”€â”€ user/           # ç”¨æˆ·åˆ‡ç‰‡
â”‚   â””â”€â”€ ...
â”œâ”€â”€ core/               # æ ¸å¿ƒæŠ½è±¡å±‚
â”‚   â”œâ”€â”€ error.rs        # ç»Ÿä¸€é”™è¯¯ç±»å‹
â”‚   â”œâ”€â”€ result.rs       # ç»“æœç±»å‹åˆ«å
â”‚   â””â”€â”€ registry.rs     # å‡½æ•°æ³¨å†Œä¸­å¿ƒ
â””â”€â”€ infra/              # åŸºç¡€è®¾æ–½å±‚
    â”œâ”€â”€ db/             # æ•°æ®åº“æŠ½è±¡
    â”œâ”€â”€ cache/          # ç¼“å­˜æŠ½è±¡
    â”œâ”€â”€ di/             # ä¾èµ–æ³¨å…¥å®¹å™¨
    â”œâ”€â”€ http/           # HTTPé€‚é…å™¨
    â”œâ”€â”€ config/         # é…ç½®ç®¡ç†
    â””â”€â”€ monitoring/     # ç›‘æ§ä¸æ—¥å¿—
```

## 3. åˆ‡ç‰‡è®¾è®¡æ¨¡å¼

### 3.1 åˆ‡ç‰‡ç›®å½•ç»“æ„

```
slices/auth/
â”œâ”€â”€ functions.rs     # æš´éœ²å‡½æ•°å®šä¹‰ï¼ˆä½¿ç”¨é™æ€åˆ†å‘ï¼‰
â”œâ”€â”€ types.rs         # æ•°æ®ç±»å‹å®šä¹‰
â”œâ”€â”€ interfaces.rs    # æ¥å£å®šä¹‰
â”œâ”€â”€ service.rs       # ä¸šåŠ¡é€»è¾‘å®ç°
â””â”€â”€ mod.rs           # æ¨¡å—å…¥å£
```

### 3.2 æ–‡ä»¶èŒè´£åˆ’åˆ†

| æ–‡ä»¶ | èŒè´£ | v7æ”¹è¿› |
|------|------|--------|
| `functions.rs` | ä½¿ç”¨æ³›å‹å‚æ•°çš„æš´éœ²å‡½æ•° | é™æ€åˆ†å‘ä»£æ›¿å® |
| `types.rs` | å®šä¹‰æ•°æ®ç»“æ„å’Œé”™è¯¯ç±»å‹ | ç»§æ‰¿v6è®¾è®¡ |
| `interfaces.rs` | å®šä¹‰æ¥å£ï¼Œå®ç°ä¾èµ–åè½¬ | ç»§æ‰¿v6è®¾è®¡ |
| `service.rs` | å®ç°ä¸šåŠ¡é€»è¾‘å’Œæ¥å£ | ç»§æ‰¿v6è®¾è®¡ |
| `mod.rs` | é‡å¯¼å‡ºå…¬å¼€APIå’Œç±»å‹ | ç»§æ‰¿v6è®¾è®¡ |

### 3.3 é™æ€åˆ†å‘å‡½æ•°æ¨¡å¼

```rust
/// v7å‡½æ•°æš´éœ²æ¨¡å¼ï¼šä½¿ç”¨æ³›å‹å‚æ•°å®ç°é™æ€åˆ†å‘
/// 
/// å‡½æ•°è·¯å¾„: auth.login
/// HTTPè·¯ç”±: POST /api/auth/login
/// æ€§èƒ½ç‰¹æ€§: ç¼–è¯‘æ—¶å•æ€åŒ–ï¼Œé›¶è¿è¡Œæ—¶å¼€é”€
pub async fn login<A>(
    auth_service: A,
    req: LoginRequest
) -> Result<LoginResponse>
where
    A: AuthService + Clone,
{
    auth_service.authenticate(req).await
}

/// å†…éƒ¨è°ƒç”¨ç¤ºä¾‹ï¼ˆç¼–è¯‘æ—¶ä¼˜åŒ–ï¼‰
pub async fn internal_login() -> Result<LoginResponse> {
    let auth_service = JwtAuthService::new();
    let req = LoginRequest { /* ... */ };
    
    // ç¼–è¯‘å™¨ä¼šå°†è¿™ä¸ªè°ƒç”¨å®Œå…¨å†…è”ï¼Œé›¶å¼€é”€
    login(auth_service, req).await
}

/// HTTPè·¯ç”±é›†æˆ
pub async fn http_login(
    req: LoginRequest
) -> HttpResponse<LoginResponse> {
    // ä»ä¾èµ–æ³¨å…¥å®¹å™¨è·å–æœåŠ¡
    let auth_service = inject::<JwtAuthService>();
    
    match login(auth_service, req).await {
        Ok(response) => HttpResponse::success(response),
        Err(e) => HttpResponse::from_error(e),
    }
}
```

## 4. æ”¹è¿›çš„åŸºç¡€è®¾æ–½ï¼ˆç»§æ‰¿v6ï¼‰

### 4.1 ä¾èµ–æ³¨å…¥ç³»ç»Ÿï¼ˆv6è®¾è®¡ï¼‰

```rust
// infra/di/mod.rs - ç»§æ‰¿v6çš„å®Œæ•´è®¾è®¡
use std::any::{Any, TypeId};
use std::collections::HashMap;
use std::sync::{Arc, RwLock};

/// ä¾èµ–æ³¨å…¥å®¹å™¨ï¼ˆç»§æ‰¿v6è®¾è®¡ï¼‰
pub struct Container {
    singletons: HashMap<TypeId, Arc<dyn Any + Send + Sync>>,
    factories: HashMap<TypeId, Box<dyn Fn() -> Arc<dyn Any + Send + Sync> + Send + Sync>>,
}

impl Container {
    // v6çš„å®Œæ•´å®ç°...
    pub fn resolve<T: 'static + ?Sized + Send + Sync>(&self) -> Option<Arc<T>> {
        // ç»§æ‰¿v6çš„å®ç°
    }
}

// v7æ”¹è¿›ï¼šä¸ºé™æ€åˆ†å‘ä¼˜åŒ–çš„æ³¨å…¥å‡½æ•°
pub fn inject<T: 'static + Send + Sync + Clone>() -> T {
    let container = CONTAINER.read().unwrap();
    container.resolve::<T>()
        .map(|arc| (*arc).clone())
        .unwrap_or_else(|| panic!("Service not registered: {}", std::any::type_name::<T>()))
}
```

### 4.2 ç»Ÿä¸€é”™è¯¯å¤„ç†ï¼ˆç»§æ‰¿v6è®¾è®¡ï¼‰

```rust
// core/error.rs - å®Œå…¨ç»§æ‰¿v6çš„ä¼˜ç§€è®¾è®¡
use thiserror::Error;

/// åº”ç”¨é”™è¯¯ç ï¼ˆç»§æ‰¿v6ï¼‰
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ErrorCode {
    BadRequest,
    Unauthorized,
    Forbidden,
    NotFound,
    Validation,
    TooManyRequests,
    Internal,
    NotImplemented,
    ServiceUnavailable,
    Database,
    Timeout,
}

/// ç»Ÿä¸€åº”ç”¨é”™è¯¯ç±»å‹ï¼ˆç»§æ‰¿v6ï¼‰
#[derive(Error, Debug)]
pub struct AppError {
    pub code: ErrorCode,
    pub message: String,
    pub context: Option<String>,
    pub trace_id: Option<String>,
    pub correlation_id: Option<String>,
    #[source]
    pub source: Option<Box<dyn std::error::Error + Send + Sync>>,
    pub location: Option<&'static str>,
}

// ç»§æ‰¿v6çš„æ‰€æœ‰ä¾¿åˆ©æ„é€ å‡½æ•°å’Œæ–¹æ³•...
```

### 4.3 å‡½æ•°æ³¨å†Œä¸­å¿ƒï¼ˆv7é€‚é…ï¼‰

```rust
// core/registry.rs - é€‚é…é™æ€åˆ†å‘çš„å‡½æ•°æ³¨å†Œ
use std::collections::HashMap;
use std::any::TypeId;

/// å‡½æ•°å…ƒæ•°æ®ï¼ˆé€‚é…é™æ€åˆ†å‘ï¼‰
#[derive(Debug, Clone)]
pub struct FunctionMetadata {
    /// å‡½æ•°è·¯å¾„ï¼ˆå¦‚ "auth.login"ï¼‰
    pub fn_path: String,
    /// HTTPè·¯ç”±ä¿¡æ¯ï¼ˆå¯é€‰ï¼‰
    pub http_route: Option<HttpRoute>,
    /// å‡½æ•°ç±»å‹IDï¼ˆç”¨äºé™æ€åˆ†å‘ï¼‰
    pub type_id: TypeId,
    /// æ˜¯å¦å†…è”ä¼˜åŒ–
    pub inline: bool,
    /// è®¿é—®çº§åˆ«
    pub access: AccessLevel,
    /// å‡½æ•°ç‰ˆæœ¬
    pub version: String,
    /// å‡½æ•°æè¿°
    pub description: Option<String>,
}

/// é™æ€åˆ†å‘å‡½æ•°æ³¨å†Œå™¨
pub struct StaticFunctionRegistry {
    functions: HashMap<String, FunctionMetadata>,
    type_mappings: HashMap<TypeId, String>,
}

impl StaticFunctionRegistry {
    /// æ³¨å†Œé™æ€åˆ†å‘å‡½æ•°
    pub fn register_function<F>(&mut self, metadata: FunctionMetadata) 
    where
        F: 'static,
    {
        let type_id = TypeId::of::<F>();
        self.type_mappings.insert(type_id, metadata.fn_path.clone());
        self.functions.insert(metadata.fn_path.clone(), metadata);
    }
    
    /// é€šè¿‡ç±»å‹è·å–å‡½æ•°è·¯å¾„
    pub fn get_path_by_type<F: 'static>(&self) -> Option<&str> {
        let type_id = TypeId::of::<F>();
        self.type_mappings.get(&type_id).map(|s| s.as_str())
    }
}
```

## 5. åˆ‡ç‰‡å®ç°ç¤ºä¾‹

### 5.1 ç”¨æˆ·è®¤è¯åˆ‡ç‰‡(auth)

#### types.rs - æ•°æ®ç±»å‹å®šä¹‰ï¼ˆç»§æ‰¿v6ï¼‰

```rust
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};

/// è®¤è¯è¯·æ±‚ï¼ˆç»§æ‰¿v6è®¾è®¡ï¼‰
#[derive(Debug, Deserialize)]
pub struct LoginRequest {
    pub username: String,
    pub password: String,
}

/// è®¤è¯å“åº”ï¼ˆç»§æ‰¿v6è®¾è®¡ï¼‰
#[derive(Debug, Serialize)]
pub struct LoginResponse {
    pub token: String,
    pub user_id: String,
    pub expires_at: DateTime<Utc>,
}

/// ç”¨æˆ·ä¼šè¯æ¨¡å‹ï¼ˆç»§æ‰¿v6è®¾è®¡ï¼‰
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserSession {
    pub user_id: String,
    pub username: String,
    pub created_at: DateTime<Utc>,
    pub expires_at: DateTime<Utc>,
}

/// è®¤è¯é”™è¯¯ï¼ˆç»§æ‰¿v6è®¾è®¡ï¼‰
#[derive(Debug, thiserror::Error)]
pub enum AuthError {
    #[error("æ— æ•ˆçš„å‡­è¯")]
    InvalidCredentials,
    #[error("ç”¨æˆ·ä¸å­˜åœ¨")]
    UserNotFound,
    #[error("ä»¤ç‰Œå·²è¿‡æœŸ")]
    TokenExpired,
    #[error("ä»¤ç‰Œæ— æ•ˆ")]
    InvalidToken,
    #[error("æ•°æ®åº“é”™è¯¯: {0}")]
    Database(String),
}

/// ç»Ÿä¸€ç»“æœç±»å‹
pub type AuthResult<T> = Result<T, AuthError>;
```

#### interfaces.rs - æ¥å£å®šä¹‰ï¼ˆç»§æ‰¿v6ï¼‰

```rust
use crate::core::error::AppResult;
use super::types::{LoginRequest, LoginResponse, UserSession, AuthResult};

/// è®¤è¯æœåŠ¡æ¥å£ï¼ˆç»§æ‰¿v6è®¾è®¡ï¼‰
pub trait AuthService: Send + Sync + Clone {
    /// éªŒè¯ç”¨æˆ·å‡­è¯å¹¶ç”Ÿæˆä»¤ç‰Œ
    async fn authenticate(&self, req: LoginRequest) -> AuthResult<LoginResponse>;
    
    /// éªŒè¯ä»¤ç‰Œæœ‰æ•ˆæ€§å¹¶è¿”å›ç”¨æˆ·ä¼šè¯
    async fn validate_token(&self, token: &str) -> AuthResult<UserSession>;
    
    /// æ’¤é”€æŒ‡å®šä»¤ç‰Œ
    async fn revoke_token(&self, token: &str) -> AuthResult<()>;
}

/// ç”¨æˆ·å­˜å‚¨æ¥å£ï¼ˆç»§æ‰¿v6è®¾è®¡ï¼‰
pub trait UserRepository: Send + Sync + Clone {
    /// é€šè¿‡ç”¨æˆ·åæŸ¥æ‰¾ç”¨æˆ·
    async fn find_by_username(&self, username: &str) -> AppResult<Option<UserModel>>;
    
    /// éªŒè¯ç”¨æˆ·å‡­è¯
    async fn verify_credentials(&self, username: &str, password: &str) -> AppResult<bool>;
}

/// ä»¤ç‰Œå­˜å‚¨æ¥å£ï¼ˆç»§æ‰¿v6è®¾è®¡ï¼‰
pub trait TokenRepository: Send + Sync + Clone {
    /// åˆ›å»ºæ–°ä»¤ç‰Œ
    async fn create_token(&self, user_id: &str) -> AppResult<String>;
    
    /// è·å–ä»¤ç‰Œå…³è”çš„ä¼šè¯
    async fn get_session(&self, token: &str) -> AppResult<Option<UserSession>>;
    
    /// æ’¤é”€ä»¤ç‰Œ
    async fn revoke(&self, token: &str) -> AppResult<()>;
}
```

#### service.rs - ä¸šåŠ¡é€»è¾‘å®ç°ï¼ˆç»§æ‰¿v6ï¼‰

```rust
use chrono::{Duration, Utc};
use uuid::Uuid;

use crate::core::error::AppError;
use crate::infra::db::Database;
use crate::infra::cache::Cache;

use super::interfaces::{AuthService, UserRepository, TokenRepository};
use super::types::{LoginRequest, LoginResponse, UserSession, AuthError, AuthResult};

/// JWTè®¤è¯æœåŠ¡å®ç°ï¼ˆç»§æ‰¿v6è®¾è®¡ï¼Œæ·»åŠ Cloneï¼‰
#[derive(Clone)]
pub struct JwtAuthService {
    user_repo: Arc<dyn UserRepository>,
    token_repo: Arc<dyn TokenRepository>,
}

impl JwtAuthService {
    pub fn new(
        user_repo: Arc<dyn UserRepository>,
        token_repo: Arc<dyn TokenRepository>
    ) -> Self {
        Self { user_repo, token_repo }
    }
}

impl AuthService for JwtAuthService {
    async fn authenticate(&self, req: LoginRequest) -> AuthResult<LoginResponse> {
        // ç»§æ‰¿v6çš„å®Œæ•´å®ç°...
        
        // éªŒè¯å‡­è¯
        let valid = self.user_repo.verify_credentials(&req.username, &req.password).await
            .map_err(|e| AuthError::Database(e.to_string()))?;
        
        if !valid {
            return Err(AuthError::InvalidCredentials);
        }
        
        // è·å–ç”¨æˆ·ID
        let user = self.user_repo.find_by_username(&req.username).await
            .map_err(|e| AuthError::Database(e.to_string()))?
            .ok_or(AuthError::UserNotFound)?;
        
        // åˆ›å»ºä»¤ç‰Œ
        let token = self.token_repo.create_token(&user.id).await
            .map_err(|e| AuthError::Database(e.to_string()))?;
        
        // æ„å»ºå“åº”
        Ok(LoginResponse {
            token,
            user_id: user.id,
            expires_at: Utc::now() + Duration::hours(24),
        })
    }
    
    async fn validate_token(&self, token: &str) -> AuthResult<UserSession> {
        // ç»§æ‰¿v6çš„å®Œæ•´å®ç°...
    }
    
    async fn revoke_token(&self, token: &str) -> AuthResult<()> {
        // ç»§æ‰¿v6çš„å®Œæ•´å®ç°...
    }
}

/// ç”¨æˆ·ä»“åº“å®ç°ï¼ˆç»§æ‰¿v6è®¾è®¡ï¼Œæ·»åŠ Cloneï¼‰
#[derive(Clone)]
pub struct DbUserRepository {
    db: Arc<dyn Database>,
}

impl UserRepository for DbUserRepository {
    // ç»§æ‰¿v6çš„å®Œæ•´å®ç°...
}

/// ä»¤ç‰Œä»“åº“å®ç°ï¼ˆç»§æ‰¿v6è®¾è®¡ï¼Œæ·»åŠ Cloneï¼‰
#[derive(Clone)]
pub struct CacheTokenRepository {
    cache: Arc<dyn Cache>,
}

impl TokenRepository for CacheTokenRepository {
    // ç»§æ‰¿v6çš„å®Œæ•´å®ç°...
}
```

#### functions.rs - é™æ€åˆ†å‘å‡½æ•°ï¼ˆv7æ ¸å¿ƒæ”¹è¿›ï¼‰

```rust
use crate::core::error::AppError;
use crate::core::result::Result;
use crate::infra::http::{HttpResponse, StatusCode};
use crate::infra::di::inject;

use super::interfaces::AuthService;
use super::types::{LoginRequest, LoginResponse, AuthError};

/// v7ç”¨æˆ·ç™»å½•API - ä½¿ç”¨é™æ€åˆ†å‘
/// 
/// å‡½æ•°è·¯å¾„: auth.login
/// HTTPè·¯ç”±: POST /api/auth/login
/// æ€§èƒ½ç‰¹æ€§: ç¼–è¯‘æ—¶å•æ€åŒ–ï¼Œé›¶è¿è¡Œæ—¶å¼€é”€
pub async fn login<A>(
    auth_service: A,
    req: LoginRequest
) -> Result<LoginResponse>
where
    A: AuthService,
{
    // è°ƒç”¨æœåŠ¡æ‰§è¡Œä¸šåŠ¡é€»è¾‘
    auth_service.authenticate(req).await
        .map_err(|e| match e {
            AuthError::InvalidCredentials => AppError::unauthorized("æ— æ•ˆçš„ç”¨æˆ·åæˆ–å¯†ç "),
            AuthError::UserNotFound => AppError::not_found("ç”¨æˆ·ä¸å­˜åœ¨"),
            _ => AppError::internal(&format!("è®¤è¯å¤±è´¥: {}", e)),
        })
}

/// v7éªŒè¯ä»¤ç‰ŒAPI - ä½¿ç”¨é™æ€åˆ†å‘
/// 
/// å‡½æ•°è·¯å¾„: auth.validate
/// HTTPè·¯ç”±: GET /api/auth/validate
pub async fn validate_token<A>(
    auth_service: A,
    token: String
) -> Result<bool>
where
    A: AuthService,
{
    match auth_service.validate_token(&token).await {
        Ok(_) => Ok(true),
        Err(e) => match e {
            AuthError::InvalidToken => Err(AppError::unauthorized("æ— æ•ˆçš„ä»¤ç‰Œ")),
            AuthError::TokenExpired => Err(AppError::unauthorized("ä»¤ç‰Œå·²è¿‡æœŸ")),
            _ => Err(AppError::internal(&format!("ä»¤ç‰ŒéªŒè¯å¤±è´¥: {}", e))),
        }
    }
}

/// v7æ’¤é”€ä»¤ç‰ŒAPI - ä½¿ç”¨é™æ€åˆ†å‘
/// 
/// å‡½æ•°è·¯å¾„: auth.revoke
/// HTTPè·¯ç”±: POST /api/auth/logout
pub async fn revoke_token<A>(
    auth_service: A,
    token: String
) -> Result<()>
where
    A: AuthService,
{
    auth_service.revoke_token(&token).await
        .map_err(|e| AppError::internal(&format!("ä»¤ç‰Œæ’¤é”€å¤±è´¥: {}", e)))
}

/// v7å†…éƒ¨å‡½æ•°ï¼šéªŒè¯ä»¤ç‰Œå¹¶è¿”å›ç”¨æˆ·ID
/// 
/// å‡½æ•°è·¯å¾„: auth.get_user_id
/// ä»…ä¾›å†…éƒ¨ä½¿ç”¨ï¼Œä¸æš´éœ²HTTPç«¯ç‚¹
pub async fn get_user_id<A>(
    auth_service: A,
    token: String
) -> Result<String>
where
    A: AuthService,
{
    let session = auth_service.validate_token(&token).await
        .map_err(|e| AppError::unauthorized(&format!("æ— æ•ˆçš„ä»¤ç‰Œ: {}", e)))?;
    
    Ok(session.user_id)
}

// HTTPè·¯ç”±é€‚é…å™¨å‡½æ•°
pub async fn http_login(req: LoginRequest) -> HttpResponse<LoginResponse> {
    let auth_service = inject::<JwtAuthService>();
    
    match login(auth_service, req).await {
        Ok(response) => HttpResponse::success(response),
        Err(e) => HttpResponse::from_error(e),
    }
}

pub async fn http_validate_token(token: String) -> HttpResponse<bool> {
    let auth_service = inject::<JwtAuthService>();
    
    match validate_token(auth_service, token).await {
        Ok(valid) => HttpResponse::success(valid),
        Err(e) => HttpResponse::from_error(e),
    }
}

pub async fn http_revoke_token(token: String) -> HttpResponse<()> {
    let auth_service = inject::<JwtAuthService>();
    
    match revoke_token(auth_service, token).await {
        Ok(_) => HttpResponse::success(()),
        Err(e) => HttpResponse::from_error(e),
    }
}
```

### 5.2 ç”¨æˆ·ç®¡ç†åˆ‡ç‰‡(user)

#### functions.rs - é™æ€åˆ†å‘å®ç°

```rust
use crate::core::result::Result;
use crate::infra::http::{HttpResponse, StatusCode};
use crate::infra::di::inject;
use crate::slices::auth::functions::get_user_id;

use super::interfaces::UserService;
use super::types::{User, UpdateProfileRequest};

/// v7è·å–ç”¨æˆ·èµ„æ–™API - ä½¿ç”¨é™æ€åˆ†å‘
/// 
/// å‡½æ•°è·¯å¾„: user.get_profile
/// HTTPè·¯ç”±: GET /api/user/profile
pub async fn get_profile<U, A>(
    user_service: U,
    auth_service: A,
    auth_token: String
) -> Result<User>
where
    U: UserService,
    A: AuthService,
{
    // 1. éªŒè¯ä»¤ç‰Œè·å–ç”¨æˆ·ID
    let user_id = get_user_id(auth_service, auth_token).await?;
    
    // 2. è·å–ç”¨æˆ·èµ„æ–™
    user_service.get_profile(&user_id).await
}

/// v7æ›´æ–°ç”¨æˆ·èµ„æ–™API - ä½¿ç”¨é™æ€åˆ†å‘
/// 
/// å‡½æ•°è·¯å¾„: user.update_profile
/// HTTPè·¯ç”±: PUT /api/user/profile
pub async fn update_profile<U, A>(
    user_service: U,
    auth_service: A,
    auth_token: String,
    req: UpdateProfileRequest
) -> Result<User>
where
    U: UserService,
    A: AuthService,
{
    // 1. éªŒè¯ä»¤ç‰Œè·å–ç”¨æˆ·ID
    let user_id = get_user_id(auth_service, auth_token).await?;
    
    // 2. æ›´æ–°ç”¨æˆ·èµ„æ–™
    user_service.update_profile(&user_id, req.email, req.display_name).await
}

// HTTPè·¯ç”±é€‚é…å™¨å‡½æ•°
pub async fn http_get_profile(auth_token: String) -> HttpResponse<User> {
    let user_service = inject::<DbUserService>();
    let auth_service = inject::<JwtAuthService>();
    
    match get_profile(user_service, auth_service, auth_token).await {
        Ok(user) => HttpResponse::success(user),
        Err(e) => HttpResponse::from_error(e),
    }
}

pub async fn http_update_profile(
    auth_token: String, 
    req: UpdateProfileRequest
) -> HttpResponse<User> {
    let user_service = inject::<DbUserService>();
    let auth_service = inject::<JwtAuthService>();
    
    match update_profile(user_service, auth_service, auth_token, req).await {
        Ok(user) => HttpResponse::success(user),
        Err(e) => HttpResponse::from_error(e),
    }
}
```

## 6. ä¾èµ–æ³¨å…¥ä¸æœåŠ¡æ³¨å†Œ

```rust
// app/di.rs - v7ä¾èµ–æ³¨å…¥é…ç½®
use crate::slices::auth::interfaces::AuthService;
use crate::slices::auth::service::{DbUserRepository, CacheTokenRepository, JwtAuthService};
use crate::slices::user::interfaces::UserService;
use crate::slices::user::service::DbUserService;

use crate::infra::db::Database;
use crate::infra::cache::Cache;
use crate::infra::di::{register, register_factory};

/// v7æœåŠ¡æ³¨å†Œ - é€‚é…é™æ€åˆ†å‘
pub fn register_services() {
    // æ³¨å†ŒåŸºç¡€è®¾æ–½
    let db = Arc::new(Database::new(
        std::env::var("DATABASE_URL").unwrap_or_else(|_| "sqlite::memory:".to_string())
    ));
    let cache = Arc::new(Cache::new(std::env::var("REDIS_URL").ok()));
    
    register(db.clone());
    register(cache.clone());
    
    // æ³¨å†Œæ•°æ®å­˜å‚¨å±‚
    let user_repo = Arc::new(DbUserRepository::new(db.clone()));
    let token_repo = Arc::new(CacheTokenRepository::new(cache.clone()));
    
    register(user_repo.clone());
    register(token_repo.clone());
    
    // æ³¨å†ŒæœåŠ¡å±‚ï¼ˆæ”¯æŒCloneçš„å…·ä½“ç±»å‹ï¼‰
    let auth_service = JwtAuthService::new(user_repo.clone(), token_repo.clone());
    let user_service = DbUserService::new(db.clone());
    
    register(auth_service);
    register(user_service);
}
```

## 7. HTTPé›†æˆä¸åº”ç”¨å¯åŠ¨

```rust
// main.rs - v7åº”ç”¨å¯åŠ¨
use axum::{
    routing::{get, post, put},
    Router,
};

mod core;
mod infra;
mod slices;
mod app;

#[tokio::main]
async fn main() {
    // åˆå§‹åŒ–æ—¥å¿—
    tracing_subscriber::fmt::init();
    
    // æ³¨å†ŒæœåŠ¡
    app::di::register_services();
    
    // æ„å»ºè·¯ç”± - ä½¿ç”¨HTTPé€‚é…å™¨å‡½æ•°
    let app = Router::new()
        // è®¤è¯è·¯ç”±
        .route("/api/auth/login", post(slices::auth::functions::http_login))
        .route("/api/auth/validate", get(slices::auth::functions::http_validate_token))
        .route("/api/auth/logout", post(slices::auth::functions::http_revoke_token))
        
        // ç”¨æˆ·è·¯ç”±
        .route("/api/user/profile", get(slices::user::functions::http_get_profile))
        .route("/api/user/profile", put(slices::user::functions::http_update_profile))
        
        // å…¨å±€ä¸­é—´ä»¶
        .layer(tower_http::cors::CorsLayer::permissive())
        .layer(tower_http::trace::TraceLayer::new_for_http());
    
    // å¯åŠ¨æœåŠ¡å™¨
    let addr = "[::1]:3000".parse().unwrap();
    tracing::info!("ğŸš€ v7æœåŠ¡å™¨å¯åŠ¨äº http://localhost:3000");
    axum::Server::bind(&addr)
        .serve(app.into_make_service())
        .await
        .unwrap();
}
```

## 8. v7æ¶æ„ä¼˜åŠ¿æ€»ç»“

### 8.2 æ€§èƒ½ç‰¹æ€§

1. **ç¼–è¯‘æ—¶å•æ€åŒ–**ï¼šæ³›å‹å‡½æ•°ä¸ºæ¯ä¸ªå…·ä½“ç±»å‹ç”Ÿæˆä¸“é—¨ç‰ˆæœ¬
2. **é›¶è¿è¡Œæ—¶å¼€é”€**ï¼šé™æ€åˆ†å‘æ¶ˆé™¤è™šæ‹Ÿå‡½æ•°è°ƒç”¨
3. **å†…è”ä¼˜åŒ–**ï¼šç¼–è¯‘å™¨å¯ä»¥å®Œå…¨å†…è”å‡½æ•°è°ƒç”¨
4. **ç±»å‹å®‰å…¨**ï¼šç¼–è¯‘æ—¶æ£€æŸ¥æ‰€æœ‰ç±»å‹åŒ¹é…

### 8.3 å¼€å‘ä½“éªŒ

1. **ç®€åŒ–å®ç°**ï¼šæ— éœ€å¤æ‚çš„è¿‡ç¨‹å®çŸ¥è¯†
2. **æ›´å¥½çš„IDEæ”¯æŒ**ï¼šæ ‡å‡†Rustè¯­æ³•ï¼Œå®Œæ•´çš„ä»£ç è¡¥å…¨
3. **æ˜“äºè°ƒè¯•**ï¼šæ ‡å‡†çš„å‡½æ•°è°ƒç”¨ï¼Œæ¸…æ™°çš„è°ƒç”¨æ ˆ
4. **æ¸è¿›å¼é‡‡ç”¨**ï¼šå¯ä»¥é€æ­¥ä»ä¼ ç»Ÿæ¶æ„è¿ç§»

### 8.4 ç»´æŠ¤æ€§

1. **ä»£ç æ¸…æ™°**ï¼šæ˜¾å¼çš„æ³›å‹å‚æ•°ï¼Œæ˜ç¡®çš„ä¾èµ–å…³ç³»
2. **æµ‹è¯•å‹å¥½**ï¼šæ˜“äºæ¨¡æ‹Ÿå’Œå•å…ƒæµ‹è¯•
3. **é‡æ„å®‰å…¨**ï¼šç¼–è¯‘å™¨ä¿è¯ç±»å‹å®‰å…¨
4. **æ–‡æ¡£å®Œæ•´**ï¼šæ ‡å‡†Rustæ–‡æ¡£å·¥å…·æ”¯æŒ

## 9. è¿ç§»æŒ‡å—

### 9.1 ä»v6è¿ç§»åˆ°v7

1. **ä¿ç•™åŸºç¡€è®¾æ–½**ï¼šå®Œå…¨ç»§æ‰¿v6çš„åŸºç¡€è®¾æ–½è®¾è®¡
2. **ä¿®æ”¹å‡½æ•°ç­¾å**ï¼šæ·»åŠ æ³›å‹å‚æ•°ä»£æ›¿å®æ³¨è§£
3. **æ·»åŠ Cloneçº¦æŸ**ï¼šä¸ºæœåŠ¡ç±»å‹æ·»åŠ Clone trait
4. **åˆ›å»ºHTTPé€‚é…å™¨**ï¼šä¸ºæ¯ä¸ªä¸šåŠ¡å‡½æ•°åˆ›å»ºHTTPé€‚é…å™¨
5. **æ›´æ–°è·¯ç”±é…ç½®**ï¼šä½¿ç”¨HTTPé€‚é…å™¨å‡½æ•°

### 9.2 æœ€ä½³å®è·µ

1. **æœåŠ¡è®¾è®¡**ï¼šç¡®ä¿æ‰€æœ‰æœåŠ¡å®ç°Clone trait
2. **å‡½æ•°è®¾è®¡**ï¼šä½¿ç”¨æ³›å‹å‚æ•°æ˜ç¡®ä¾èµ–
3. **é”™è¯¯å¤„ç†**ï¼šç»§ç»­ä½¿ç”¨v6çš„ç»Ÿä¸€é”™è¯¯ç³»ç»Ÿ
4. **æµ‹è¯•ç­–ç•¥**ï¼šåˆ©ç”¨é™æ€åˆ†å‘çš„æµ‹è¯•ä¼˜åŠ¿
5. **æ€§èƒ½ä¼˜åŒ–**ï¼šåˆ©ç”¨ç¼–è¯‘å™¨çš„å†…è”ä¼˜åŒ–

---

**v7æ¶æ„æ€»ç»“**ï¼šé€šè¿‡ä½¿ç”¨é™æ€åˆ†å‘+æ³›å‹ä»£æ›¿å¤æ‚çš„å®ç³»ç»Ÿï¼Œv7åœ¨ä¿æŒv6æ‰€æœ‰ä¼˜ç§€ç‰¹æ€§çš„åŸºç¡€ä¸Šï¼Œæä¾›äº†æ›´ç®€æ´ã€æ›´å¯é ã€æ€§èƒ½æ›´ä¼˜çš„æ¶æ„æ–¹æ¡ˆã€‚è¿™æ˜¯ä¸€ä¸ªçœŸæ­£å¯è½åœ°çš„ç”Ÿäº§çº§æ¶æ„è®¾è®¡ã€‚ 