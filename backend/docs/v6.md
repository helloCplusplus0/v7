# ğŸš€ è½»é‡é«˜æ•ˆçš„å‡½æ•°å¼åˆ‡ç‰‡æ¶æ„ v6.0

## 1. æ ¸å¿ƒè®¾è®¡ç†å¿µ

v6è®¾è®¡ç»§æ‰¿å¹¶å¢å¼ºäº†v5çš„å‡½æ•°ä¼˜å…ˆç†å¿µï¼ŒåŒæ—¶æä¾›äº†æ›´å®Œå–„çš„åŸºç¡€è®¾æ–½æ”¯æŒï¼š

- **å‡½æ•°ä¼˜å…ˆ**ï¼šä»¥å‡½æ•°ä¸ºåŸºæœ¬å•å…ƒï¼Œä¼˜å…ˆäºç»“æ„ä½“å’Œç±»
- **åŒè·¯å¾„æš´éœ²**ï¼šå‡½æ•°åŒæ—¶æ”¯æŒå†…éƒ¨è°ƒç”¨å’Œå¤–éƒ¨HTTPè®¿é—®
- **æ¥å£é©±åŠ¨è®¾è®¡**ï¼šé€šè¿‡æ¥å£å®ç°æ¾è€¦åˆï¼Œæ”¯æŒçµæ´»ç»„åˆ
- **ç±»å‹å®‰å…¨æ³¨å…¥**ï¼šæ”¹è¿›ä¾èµ–æ³¨å…¥æœºåˆ¶ï¼Œç¡®ä¿ç¼–è¯‘æ—¶ç±»å‹å®‰å…¨
- **é›¶å¼€é”€è°ƒç”¨è·¯å¾„**ï¼šä¼˜åŒ–å†…éƒ¨è°ƒç”¨æ€§èƒ½ï¼Œæ¶ˆé™¤é—´æ¥å¼€é”€
- **æ˜¾å¼ä¾èµ–**ï¼šé€šè¿‡å‚æ•°æ˜ç¡®ä¾èµ–å…³ç³»ï¼Œä¾¿äºæµ‹è¯•å’Œç»´æŠ¤
- **ç»Ÿä¸€é”™è¯¯å¤„ç†**ï¼šå®ç°å®Œæ•´çš„é”™è¯¯å¤„ç†ç³»ç»Ÿï¼Œæ”¯æŒä¸Šä¸‹æ–‡å’Œè¿½è¸ª

## 2. æ¶æ„åˆ†å±‚ä¸ç»„ä»¶

```
app/
â”œâ”€â”€ slices/             # åŠŸèƒ½åˆ‡ç‰‡
â”‚   â”œâ”€â”€ auth/           # è®¤è¯åˆ‡ç‰‡
â”‚   â”œâ”€â”€ user/           # ç”¨æˆ·åˆ‡ç‰‡
â”‚   â””â”€â”€ ...
â”œâ”€â”€ core/               # æ ¸å¿ƒæŠ½è±¡å±‚
â”‚   â”œâ”€â”€ error.rs        # ç»Ÿä¸€é”™è¯¯ç±»å‹
â”‚   â”œâ”€â”€ result.rs       # ç»“æœç±»å‹åˆ«å
â”‚   â””â”€â”€ registry.rs     # å‡½æ•°æ³¨å†Œä¸­å¿ƒ
â””â”€â”€ infra/              # åŸºç¡€è®¾æ–½å±‚
    â”œâ”€â”€ db/             # æ•°æ®åº“æŠ½è±¡
    â”œâ”€â”€ cache/          # ç¼“å­˜æŠ½è±¡
    â”œâ”€â”€ di/             # ä¾èµ–æ³¨å…¥å®¹å™¨
    â”œâ”€â”€ http/           # HTTPé€‚é…å™¨
    â”œâ”€â”€ config/         # é…ç½®ç®¡ç†
    â””â”€â”€ monitoring/     # ç›‘æ§ä¸æ—¥å¿—
```

## 3. åˆ‡ç‰‡è®¾è®¡æ¨¡å¼

### 3.1 åˆ‡ç‰‡ç›®å½•ç»“æ„

```
slices/auth/
â”œâ”€â”€ functions.rs     # æš´éœ²å‡½æ•°å®šä¹‰
â”œâ”€â”€ types.rs         # æ•°æ®ç±»å‹å®šä¹‰
â”œâ”€â”€ interfaces.rs    # æ¥å£å®šä¹‰ï¼ˆä¹‹å‰çš„traits.rsï¼‰
â”œâ”€â”€ service.rs       # ä¸šåŠ¡é€»è¾‘å®ç°
â””â”€â”€ mod.rs           # æ¨¡å—å…¥å£
```

### 3.2 æ–‡ä»¶èŒè´£åˆ’åˆ†

| æ–‡ä»¶ | èŒè´£ | ç¤ºä¾‹ |
|------|------|------|
| `functions.rs` | æš´éœ²å‡½æ•°ï¼Œå¤„ç†HTTPè¯·æ±‚å’Œå†…éƒ¨è°ƒç”¨ | `login()`, `validate_token()` |
| `types.rs` | å®šä¹‰æ•°æ®ç»“æ„å’Œé”™è¯¯ç±»å‹ | `LoginRequest`, `AuthError` |
| `interfaces.rs` | å®šä¹‰æ¥å£ï¼Œå®ç°ä¾èµ–åè½¬ | `AuthService`, `TokenGenerator` |
| `service.rs` | å®ç°ä¸šåŠ¡é€»è¾‘å’Œæ¥å£ | `JwtAuthService` |
| `mod.rs` | é‡å¯¼å‡ºå…¬å¼€APIå’Œç±»å‹ | `pub use functions::*` |

### 3.3 å‡½æ•°æš´éœ²æ¨¡å¼

```rust
/// ç”¨æˆ·ç™»å½•API
#[expose(
    fn_path = "auth.login",      // å†…éƒ¨å‡½æ•°è·¯å¾„
    http = "POST /api/auth/login", // HTTPè·¯ç”±
    inline = true,               // æç¤ºç¼–è¯‘å™¨å†…è”ä¼˜åŒ–
    access = "public"            // è®¿é—®æ§åˆ¶
)]
pub async fn login(
    // å‚æ•°ä½¿ç”¨ä¾èµ–æ³¨å…¥æˆ–ç›´æ¥æ¥æ”¶
    auth_service: impl AsRef<dyn AuthService>,
    req: LoginRequest
) -> Result<LoginResponse> {
    auth_service.as_ref().login(req).await
}
```

## 4. æ”¹è¿›çš„åŸºç¡€è®¾æ–½

### 4.1 ä¾èµ–æ³¨å…¥ç³»ç»Ÿ

v6æä¾›äº†è½»é‡çº§ä½†åŠŸèƒ½å®Œæ•´çš„ä¾èµ–æ³¨å…¥å®¹å™¨ï¼Œè§£å†³äº†v5ä¸­ä¾èµ–ç®¡ç†çš„é—®é¢˜ï¼š

```rust
// infra/di/mod.rs
use std::any::{Any, TypeId};
use std::collections::HashMap;
use std::sync::{Arc, RwLock};

// å…¨å±€ä¾èµ–å®¹å™¨
static CONTAINER: RwLock<Container> = RwLock::new(Container::new());

/// ä¾èµ–æ³¨å…¥å®¹å™¨
pub struct Container {
    singletons: HashMap<TypeId, Arc<dyn Any + Send + Sync>>,
    factories: HashMap<TypeId, Box<dyn Fn() -> Arc<dyn Any + Send + Sync> + Send + Sync>>,
}

impl Container {
    pub fn new() -> Self {
        Self {
            singletons: HashMap::new(),
            factories: HashMap::new(),
        }
    }
    
    // æ³¨å†Œå•ä¾‹æœåŠ¡
    pub fn register<T: 'static + ?Sized + Send + Sync>(&mut self, instance: Arc<T>) {
        self.singletons.insert(TypeId::of::<T>(), instance as Arc<dyn Any + Send + Sync>);
    }
    
    // æ³¨å†Œå·¥å‚å‡½æ•°
    pub fn register_factory<T, F>(&mut self, factory: F)
    where
        T: 'static + ?Sized + Send + Sync,
        F: Fn() -> Arc<T> + Send + Sync + 'static,
    {
        let factory_wrapper = move || factory() as Arc<dyn Any + Send + Sync>;
        self.factories.insert(TypeId::of::<T>(), Box::new(factory_wrapper));
    }
    
    // è§£ææœåŠ¡
    pub fn resolve<T: 'static + ?Sized + Send + Sync>(&self) -> Option<Arc<T>> {
        // å…ˆå°è¯•ä»å•ä¾‹è·å–
        if let Some(instance) = self.singletons.get(&TypeId::of::<T>()) {
            if let Ok(typed) = instance.clone().downcast::<T>() {
                return Some(typed);
            }
        }
        
        // å†å°è¯•ä»å·¥å‚åˆ›å»º
        if let Some(factory) = self.factories.get(&TypeId::of::<T>()) {
            let instance = factory();
            if let Ok(typed) = instance.downcast::<T>() {
                return Some(typed);
            }
        }
        
        None
    }
}

// æ³¨å†Œå•ä¾‹æœåŠ¡
pub fn register<T: 'static + ?Sized + Send + Sync>(instance: impl Into<Arc<T>>) {
    let mut container = CONTAINER.write().unwrap();
    container.register(instance.into());
}

// æ³¨å†Œå·¥å‚å‡½æ•°
pub fn register_factory<T, F>(factory: F)
where
    T: 'static + ?Sized + Send + Sync,
    F: Fn() -> Arc<T> + Send + Sync + 'static,
{
    let mut container = CONTAINER.write().unwrap();
    container.register_factory(factory);
}

// è§£ææœåŠ¡ï¼ˆå¿…é¡»å­˜åœ¨ï¼‰
pub fn inject<T: 'static + ?Sized + Send + Sync>() -> Arc<T> {
    let container = CONTAINER.read().unwrap();
    container.resolve::<T>()
        .unwrap_or_else(|| panic!("Service not registered: {}", std::any::type_name::<T>()))
}

// å°è¯•è§£ææœåŠ¡ï¼ˆå¯èƒ½ä¸å­˜åœ¨ï¼‰
pub fn try_inject<T: 'static + ?Sized + Send + Sync>() -> Option<Arc<T>> {
    let container = CONTAINER.read().unwrap();
    container.resolve::<T>()
}

// AsRefå®ç°ï¼Œä½¿æ¥å£æ³¨å…¥æ›´è‡ªç„¶
impl<T: ?Sized + 'static> AsRef<T> for Arc<T> {
    fn as_ref(&self) -> &T {
        Arc::as_ref(self)
    }
}
```

### 4.2 ç»Ÿä¸€é”™è¯¯å¤„ç†

v6æä¾›äº†ç»Ÿä¸€çš„é”™è¯¯ç±»å‹ç³»ç»Ÿï¼Œè§£å†³äº†v5ä¸­é”™è¯¯å¤„ç†ä¸ä¸€è‡´çš„é—®é¢˜ï¼š

```rust
// core/error.rs
use std::fmt;
use thiserror::Error;

/// åº”ç”¨é”™è¯¯ç 
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ErrorCode {
    // å®¢æˆ·ç«¯é”™è¯¯ï¼ˆ400ç³»åˆ—ï¼‰
    BadRequest,          // 400
    Unauthorized,        // 401
    Forbidden,           // 403
    NotFound,            // 404
    Validation,          // 422
    TooManyRequests,     // 429
    
    // æœåŠ¡å™¨é”™è¯¯ï¼ˆ500ç³»åˆ—ï¼‰
    Internal,            // 500
    NotImplemented,      // 501
    ServiceUnavailable,  // 503
    Database,            // 500 (æ•°æ®åº“é”™è¯¯)
    Timeout,             // 504
}

impl ErrorCode {
    /// è·å–HTTPçŠ¶æ€ç 
    pub fn status_code(&self) -> u16 {
        match self {
            Self::BadRequest => 400,
            Self::Unauthorized => 401,
            Self::Forbidden => 403,
            Self::NotFound => 404,
            Self::Validation => 422,
            Self::TooManyRequests => 429,
            Self::Internal => 500,
            Self::NotImplemented => 501,
            Self::ServiceUnavailable => 503,
            Self::Database => 500,
            Self::Timeout => 504,
        }
    }
}

/// ç»Ÿä¸€åº”ç”¨é”™è¯¯ç±»å‹
#[derive(Error, Debug)]
pub struct AppError {
    /// é”™è¯¯ä»£ç 
    pub code: ErrorCode,
    /// é”™è¯¯æ¶ˆæ¯
    pub message: String,
    /// é”™è¯¯ä¸Šä¸‹æ–‡ï¼ˆå¯é€‰ï¼‰
    pub context: Option<String>,
    /// æºé”™è¯¯ï¼ˆå¯é€‰ï¼‰
    #[source]
    pub source: Option<Box<dyn std::error::Error + Send + Sync>>,
    /// é”™è¯¯å‘ç”Ÿä½ç½®
    pub location: Option<&'static str>,
}

impl AppError {
    /// åˆ›å»ºæ–°é”™è¯¯
    pub fn new(code: ErrorCode, message: impl Into<String>) -> Self {
        Self {
            code,
            message: message.into(),
            context: None,
            source: None,
            location: None,
        }
    }
    
    /// æ·»åŠ ä¸Šä¸‹æ–‡
    pub fn with_context(mut self, context: impl Into<String>) -> Self {
        self.context = Some(context.into());
        self
    }
    
    /// æ·»åŠ æºé”™è¯¯
    pub fn with_source<E: std::error::Error + Send + Sync + 'static>(mut self, source: E) -> Self {
        self.source = Some(Box::new(source));
        self
    }
    
    /// æ·»åŠ ä½ç½®ä¿¡æ¯
    pub fn with_location(mut self, location: &'static str) -> Self {
        self.location = Some(location);
        self
    }
    
    // ä¾¿åˆ©æ„é€ å‡½æ•°
    pub fn bad_request(message: impl Into<String>) -> Self {
        Self::new(ErrorCode::BadRequest, message)
    }
    
    pub fn unauthorized(message: impl Into<String>) -> Self {
        Self::new(ErrorCode::Unauthorized, message)
    }
    
    pub fn forbidden(message: impl Into<String>) -> Self {
        Self::new(ErrorCode::Forbidden, message)
    }
    
    pub fn not_found(message: impl Into<String>) -> Self {
        Self::new(ErrorCode::NotFound, message)
    }
    
    pub fn validation(message: impl Into<String>) -> Self {
        Self::new(ErrorCode::Validation, message)
    }
    
    pub fn internal(message: impl Into<String>) -> Self {
        Self::new(ErrorCode::Internal, message)
    }
    
    pub fn database(message: impl Into<String>) -> Self {
        Self::new(ErrorCode::Database, message)
    }
}

impl fmt::Display for AppError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "[{}] {}", self.code.status_code(), self.message)?;
        
        if let Some(context) = &self.context {
            write!(f, " (Context: {})", context)?;
        }
        
        if let Some(location) = self.location {
            write!(f, " (Location: {})", location)?;
        }
        
        Ok(())
    }
}

/// åº”ç”¨ç»“æœç±»å‹
pub type Result<T> = std::result::Result<T, AppError>;

/// é”™è¯¯å®šä½å®
#[macro_export]
macro_rules! err_loc {
    ($err:expr) => {
        $err.with_location(concat!(file!(), ":", line!()))
    };
}
```

### 4.3 åˆ†å±‚æ•°æ®åº“æŠ½è±¡

v6å¼•å…¥äº†åˆ†å±‚æ•°æ®åº“æŠ½è±¡ï¼Œè§£å†³äº†v5ä¸­æ•°æ®è®¿é—®ä¸ä¸€è‡´çš„é—®é¢˜ï¼š

```rust
// infra/db/mod.rs
use async_trait::async_trait;
use crate::core::{Result, AppError};

/// åŸºç¡€æ•°æ®åº“æ¥å£ - é€‚ç”¨äº80%çš„ç®€å•åº”ç”¨åœºæ™¯
#[async_trait]
pub trait Database: Send + Sync {
    /// æ‰§è¡ŒæŸ¥è¯¢å¹¶è¿”å›ç»“æœ
    async fn query<T: serde::de::DeserializeOwned>(&self, sql: &str, params: &[&(dyn ToSql + Sync)]) -> Result<Vec<T>>;
    
    /// æ‰§è¡ŒæŸ¥è¯¢å¹¶è¿”å›å•ä¸ªç»“æœ
    async fn query_one<T: serde::de::DeserializeOwned>(&self, sql: &str, params: &[&(dyn ToSql + Sync)]) -> Result<T>;
    
    /// æ‰§è¡ŒæŸ¥è¯¢å¹¶è¿”å›å¯é€‰ç»“æœ
    async fn query_opt<T: serde::de::DeserializeOwned>(&self, sql: &str, params: &[&(dyn ToSql + Sync)]) -> Result<Option<T>>;
    
    /// æ‰§è¡Œæ›´æ–°å¹¶è¿”å›å½±å“çš„è¡Œæ•°
    async fn execute(&self, sql: &str, params: &[&(dyn ToSql + Sync)]) -> Result<u64>;
    
    /// æ£€æŸ¥æ•°æ®åº“å¥åº·çŠ¶æ€
    async fn health_check(&self) -> Result<bool>;
}

/// é«˜çº§æ•°æ®åº“æ¥å£ - æ”¯æŒäº‹åŠ¡å’Œæ‰¹é‡æ“ä½œ
#[async_trait]
pub trait AdvancedDatabase: Database {
    /// å¼€å§‹äº‹åŠ¡
    async fn begin_transaction(&self) -> Result<Transaction>;
    
    /// æ‰¹é‡æ‰§è¡Œå¤šä¸ªæŸ¥è¯¢
    async fn batch(&self, operations: Vec<BatchOperation>) -> Result<Vec<u64>>;
}

/// æ•°æ®åº“äº‹åŠ¡
#[async_trait]
pub trait Transaction: Send + Sync {
    /// åœ¨äº‹åŠ¡ä¸­æ‰§è¡ŒæŸ¥è¯¢
    async fn query<T: serde::de::DeserializeOwned>(&self, sql: &str, params: &[&(dyn ToSql + Sync)]) -> Result<Vec<T>>;
    
    /// åœ¨äº‹åŠ¡ä¸­æ‰§è¡Œæ›´æ–°
    async fn execute(&self, sql: &str, params: &[&(dyn ToSql + Sync)]) -> Result<u64>;
    
    /// æäº¤äº‹åŠ¡
    async fn commit(self: Box<Self>) -> Result<()>;
    
    /// å›æ»šäº‹åŠ¡
    async fn rollback(self: Box<Self>) -> Result<()>;
}

/// æ‰¹é‡æ“ä½œå®šä¹‰
pub struct BatchOperation {
    pub sql: String,
    pub params: Vec<Box<dyn ToSql + Send + Sync>>,
}

/// æŸ¥è¯¢æ„å»ºå™¨æ¥å£
pub trait QueryBuilder {
    /// é€‰æ‹©å­—æ®µ
    fn select(self, fields: &[&str]) -> Self;
    
    /// ä»è¡¨æŸ¥è¯¢
    fn from(self, table: &str) -> Self;
    
    /// æ·»åŠ WHEREæ¡ä»¶
    fn where_clause(self, condition: &str, params: Vec<Box<dyn ToSql + Send + Sync>>) -> Self;
    
    /// æ·»åŠ ORDER BY
    fn order_by(self, column: &str, descending: bool) -> Self;
    
    /// æ·»åŠ LIMIT
    fn limit(self, count: u64) -> Self;
    
    /// æ·»åŠ OFFSET
    fn offset(self, count: u64) -> Self;
    
    /// æ„å»ºSQL
    fn build(self) -> (String, Vec<Box<dyn ToSql + Send + Sync>>);
}
```

### 4.4 ç¼“å­˜æŠ½è±¡ä¸ç®¡ç†

v6æä¾›äº†æ”¹è¿›çš„ç¼“å­˜æŠ½è±¡ï¼Œè§£å†³äº†v5ä¸­ç¼“å­˜ç®¡ç†ä¸ä¸€è‡´çš„é—®é¢˜ï¼š

```rust
// infra/cache/mod.rs
use async_trait::async_trait;
use crate::core::Result;

/// ç¼“å­˜æ¥å£
#[async_trait]
pub trait Cache: Send + Sync {
    /// è·å–å€¼
    async fn get(&self, key: &str) -> Result<Option<String>>;
    
    /// è®¾ç½®å€¼
    async fn set(&self, key: &str, value: &str, ttl_seconds: Option<u64>) -> Result<()>;
    
    /// åˆ é™¤å€¼
    async fn delete(&self, key: &str) -> Result<()>;
    
    /// æ£€æŸ¥é”®æ˜¯å¦å­˜åœ¨
    async fn exists(&self, key: &str) -> Result<bool>;
    
    /// æ¸…ç©ºç¼“å­˜
    async fn clear(&self) -> Result<()>;
    
    /// å¢åŠ è®¡æ•°å™¨
    async fn increment(&self, key: &str, amount: i64) -> Result<i64>;
    
    /// è®¾ç½®é”®è¿‡æœŸæ—¶é—´
    async fn expire(&self, key: &str, seconds: u64) -> Result<()>;
}

/// ç¼“å­˜é”®ç”Ÿæˆå™¨ç‰¹æ€§
pub trait CacheKeyGenerator: Send + Sync {
    /// ç”Ÿæˆç¼“å­˜é”®
    fn generate(&self, prefix: &str, parts: &[&str]) -> String {
        format!("{}:{}", prefix, parts.join(":"))
    }
    
    /// ç”Ÿæˆå®ä½“ç¼“å­˜é”®
    fn entity_key(&self, entity_type: &str, id: &str) -> String {
        self.generate(entity_type, &[id])
    }
    
    /// ç”Ÿæˆåˆ—è¡¨ç¼“å­˜é”®
    fn list_key(&self, entity_type: &str, filter: &str) -> String {
        self.generate(&format!("{}:list", entity_type), &[filter])
    }
    
    /// ç”Ÿæˆç”¨æˆ·ç›¸å…³ç¼“å­˜é”®
    fn user_key(&self, user_id: &str, resource: &str) -> String {
        self.generate("user", &[user_id, resource])
    }
}

/// é»˜è®¤ç¼“å­˜é”®ç”Ÿæˆå™¨
pub struct DefaultCacheKeyGenerator;

impl CacheKeyGenerator for DefaultCacheKeyGenerator {}
```

### 4.5 é…ç½®ç®¡ç†

v6æä¾›äº†æ”¹è¿›çš„é…ç½®ç®¡ç†ï¼Œè§£å†³äº†v5ä¸­é…ç½®ç®¡ç†ä¸å®Œå–„çš„é—®é¢˜ï¼š

```rust
// infra/config/mod.rs
use serde::Deserialize;
use std::collections::HashMap;
use std::sync::RwLock;

/// åº”ç”¨ç¯å¢ƒ
#[derive(Debug, Clone, Copy, PartialEq, Eq, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum Environment {
    Development,
    Test,
    Staging,
    Production,
}

impl Environment {
    /// ä»ç¯å¢ƒå˜é‡æ£€æµ‹ç¯å¢ƒ
    pub fn from_env() -> Self {
        let env_var = std::env::var("APP_ENV")
            .or_else(|_| std::env::var("RUST_ENV"))
            .unwrap_or_else(|_| "development".to_string());
            
        match env_var.to_lowercase().as_str() {
            "production" | "prod" => Self::Production,
            "staging" => Self::Staging,
            "test" => Self::Test,
            _ => Self::Development,
        }
    }
    
    pub fn is_production(&self) -> bool {
        *self == Self::Production
    }
    
    pub fn is_development(&self) -> bool {
        *self == Self::Development
    }
}

/// åº”ç”¨é…ç½®ç®¡ç†å™¨
pub struct Config {
    environment: Environment,
    values: RwLock<HashMap<String, String>>,
}

impl Config {
    /// åˆ›å»ºæ–°é…ç½®
    pub fn new(environment: Environment) -> Self {
        Self {
            environment,
            values: RwLock::new(HashMap::new()),
        }
    }
    
    /// ä»ç¯å¢ƒå˜é‡åˆ›å»ºé…ç½®
    pub fn from_env() -> Self {
        let environment = Environment::from_env();
        let mut config = Self::new(environment);
        
        // åŠ è½½.envæ–‡ä»¶ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        if let Ok(env_path) = std::env::var("ENV_FILE") {
            if let Err(e) = dotenv::from_path(&env_path) {
                eprintln!("Warning: Failed to load .env file: {}", e);
            }
        } else if environment.is_development() {
            let _ = dotenv::dotenv(); // å°è¯•åŠ è½½.envæ–‡ä»¶
        }
        
        config
    }
    
    /// è·å–ç¯å¢ƒ
    pub fn environment(&self) -> Environment {
        self.environment
    }
    
    /// è·å–å­—ç¬¦ä¸²å€¼
    pub fn get<T: AsRef<str>>(&self, key: T) -> Option<String> {
        let key_str = key.as_ref();
        
        // å…ˆå°è¯•ä»å†…å­˜ç¼“å­˜è·å–
        if let Some(value) = self.values.read().unwrap().get(key_str) {
            return Some(value.clone());
        }
        
        // å†å°è¯•ä»ç¯å¢ƒå˜é‡è·å–
        if let Ok(value) = std::env::var(key_str) {
            // ç¼“å­˜ç»“æœ
            self.values.write().unwrap().insert(key_str.to_string(), value.clone());
            return Some(value);
        }
        
        None
    }
    
    /// è·å–å¸¦é»˜è®¤å€¼çš„å­—ç¬¦ä¸²
    pub fn get_or<T: AsRef<str>>(&self, key: T, default: &str) -> String {
        self.get(key).unwrap_or_else(|| default.to_string())
    }
    
    /// è·å–æ•´æ•°å€¼
    pub fn get_int<T: AsRef<str>>(&self, key: T) -> Option<i64> {
        self.get(key).and_then(|v| v.parse::<i64>().ok())
    }
    
    /// è·å–æµ®ç‚¹å€¼
    pub fn get_float<T: AsRef<str>>(&self, key: T) -> Option<f64> {
        self.get(key).and_then(|v| v.parse::<f64>().ok())
    }
    
    /// è·å–å¸ƒå°”å€¼
    pub fn get_bool<T: AsRef<str>>(&self, key: T) -> Option<bool> {
        self.get(key).and_then(|v| match v.to_lowercase().as_str() {
            "true" | "1" | "yes" | "on" => Some(true),
            "false" | "0" | "no" | "off" => Some(false),
            _ => None,
        })
    }
    
    /// è®¾ç½®å€¼
    pub fn set<T: AsRef<str>, V: AsRef<str>>(&self, key: T, value: V) {
        self.values.write().unwrap().insert(
            key.as_ref().to_string(),
            value.as_ref().to_string(),
        );
    }
    
    /// è·å–æ•°æ®åº“URL
    pub fn database_url(&self) -> String {
        self.get("DATABASE_URL")
            .or_else(|| self.get("database_url"))
            .unwrap_or_else(|| {
                if self.environment.is_production() {
                    "postgresql://localhost/prod_db".to_string()
                } else {
                    "sqlite:./dev.db".to_string()
                }
            })
    }
    
    /// è·å–æœåŠ¡ç«¯å£
    pub fn port(&self) -> u16 {
        self.get_int("PORT")
            .or_else(|| self.get_int("port"))
            .unwrap_or(if self.environment.is_production() { 8080 } else { 3000 })
            as u16
    }
}
```

è¿™ä¸ªMVPç¤ºä¾‹å±•ç¤ºäº†v6æ¶æ„çš„æ ¸å¿ƒç‰¹æ€§:

1. **å‡½æ•°ä¼˜å…ˆ**: é€šè¿‡`#[expose]`å®æš´éœ²å‡½æ•°ï¼Œè€Œéç»“æ„ä½“æ–¹æ³•
2. **ç±»å‹å®‰å…¨æ³¨å…¥**: ä½¿ç”¨`inject!`å®è·å–ç±»å‹å®‰å…¨çš„ä¾èµ–
3. **æ¥å£é©±åŠ¨**: é€šè¿‡æ¥å£åˆ†ç¦»å®šä¹‰ä¸å®ç°ï¼Œä¿æŒæ¾è€¦åˆ
4. **åˆ†å±‚è®¾è®¡**: æ¸…æ™°åˆ’åˆ†APIå‡½æ•°ã€ä¸šåŠ¡æœåŠ¡å’Œæ•°æ®è®¿é—®
5. **é”™è¯¯å¤„ç†**: ç»Ÿä¸€çš„é”™è¯¯ç±»å‹å’Œä¼ æ’­æœºåˆ¶
6. **é›¶ä¾èµ–å†²çª**: é€šè¿‡ä¾èµ–æ³¨å…¥å®¹å™¨ç®¡ç†æœåŠ¡ç”Ÿå‘½å‘¨æœŸ

è¯¥æ¶æ„æ—¢ä¿æŒäº†v5çš„å‡½æ•°åŒ–è®¾è®¡ç†å¿µï¼Œåˆè§£å†³äº†å…¶ä¾èµ–ç®¡ç†å’Œé”™è¯¯å¤„ç†çš„é—®é¢˜ï¼Œæ˜¯ä¸€ä¸ªå¹³è¡¡æ€§èƒ½ä¸å¯ç»´æŠ¤æ€§çš„æœ€ä½³å®è·µæ–¹æ¡ˆã€‚

